# -*- coding: utf-8 -*-
"""Assignment 6 __Numpy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gkWKhrJxeK5RjeZdD2z-D6HvF6kK8iBB

import important libraries
"""

import numpy as np
import matplotlib as plt
import pandas as pd
import math
from keras.utils import to_categorical
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, precision_score, recall_score

"""load our data"""

train=pd.read_csv('/content/optdigits.tra')
test=pd.read_csv('/content/optdigits.tes')

"""split dataset"""

x_train=train.iloc[:,:-1].values
y_train=train.iloc[:,-1].values
x_test=test.iloc[:,:-1].values
y_test=test.iloc[:,-1].values

"""normalize data"""

scaler = StandardScaler()
x_train = scaler.fit_transform(x_train)
x_test = scaler.transform(x_test)

"""one hot encoding"""

output_dim = 10
y_train_encoded = np.eye(output_dim)[y_train.astype(int)]

"""build neural networks"""

input_dim = x_train.shape[1]
hidden_dim = 64

"""intialize needed parameters and functions"""

w0 = 2 * np.random.random((input_dim, hidden_dim)) - 1
b0 = 2 * np.random.random((1, hidden_dim)) - 1
w1 = 2 * np.random.random((hidden_dim, output_dim)) - 1
b1 = 2 * np.random.random((1, output_dim)) - 1

lr = 0.1
 epochs = 3000
 reg_lambda = 0.001
 lr_decay = 0.95
 batch_size=64

def sigmoid(x):
  return 1 / (1 + np.exp(-x))

def sigmoid_derivative(x):
  return x * (1- x)

for epoch in range(epochs):
    for i in range(0, x_train.shape[0], batch_size):
        x_batch = x_train[i:i+batch_size]
        y_batch = y_train_encoded[i:i+batch_size]

        # Forward propagation
        l0 = x_batch
        l1 = sigmoid(np.dot(l0, w0) + b0)
        l2 = sigmoid(np.dot(l1, w1) + b1)

        # Backward propagation
        l2_error = y_batch - l2
        l2_delta = l2_error * sigmoid_derivative(l2)
        l1_error = l2_delta.dot(w1.T)
        l1_delta = l1_error * sigmoid_derivative(l1)

        # Update w and b
        w1 += lr * (l1.T.dot(l2_delta) - reg_lambda * w1)
        b1 += np.sum(l2_delta, axis=0, keepdims=True) * lr
        w0 += lr * (l0.T.dot(l1_delta) - reg_lambda * w0)
        b0 += np.sum(l1_delta, axis=0, keepdims=True) * lr


    lr *= lr_decay

l0 = x_test
l1 = sigmoid(np.dot(l0, w0) + b0)
l2 = sigmoid(np.dot(l1, w1) + b1)

predicted_labels = np.argmax(l2, axis=1)

"""find accuracy"""

accuracy = accuracy_score(y_test, predicted_labels)
print("Total Accuracy:", accuracy)